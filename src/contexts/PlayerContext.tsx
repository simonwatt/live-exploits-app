import React, { createContext, useReducer, useContext, useEffect } from 'react';
import apiClient from '../utils/apiClient';

// Define action types
const SET_PLAYERS = 'SET_PLAYERS';
const ADD_PLAYER = 'ADD_PLAYER';
const UPDATE_PLAYER = 'UPDATE_PLAYER';
const DELETE_PLAYER = 'DELETE_PLAYER';
const SET_TAGS = 'SET_TAGS';

// Action types for notes
const SET_NOTES = 'SET_NOTES';
const ADD_NOTE = 'ADD_NOTE';
const UPDATE_NOTE = 'UPDATE_NOTE';
const DELETE_NOTE = 'DELETE_NOTE';

// Initial state
const initialState = {
  players: [],
  tags: [],
  tagsLoaded: false,
  notes: [],
};

// Reducer function
const playerReducer = (state, action) => {
  switch (action.type) {
    case SET_PLAYERS:
      // Remove 'notes' from player objects if present
      return {
        ...state,
        players: action.payload.map((player) => {
          const { notes, ...rest } = player;
          return rest;
        }),
      };
    case ADD_PLAYER:
      return {
        ...state,
        players: [...state.players, action.payload].sort((a, b) =>
          a.name.localeCompare(b.name)
        ),
      };
    case UPDATE_PLAYER:
      return {
        ...state,
        players: state.players.map((p) =>
          p.id === action.payload.id ? action.payload : p
        ),
      };
    case DELETE_PLAYER:
      return {
        ...state,
        players: state.players.filter((p) => p.id !== action.payload),
      };
    case SET_TAGS:
      return { ...state, tags: action.payload, tagsLoaded: true };

    // Notes actions
    case SET_NOTES:
      return { ...state, notes: action.payload };
    case ADD_NOTE:
      return { ...state, notes: [action.payload, ...state.notes] };
    case UPDATE_NOTE:
      return {
        ...state,
        notes: state.notes.map((note) =>
          note.id === action.payload.id ? action.payload : note
        ),
      };
    case DELETE_NOTE:
      return {
        ...state,
        notes: state.notes.filter((note) => note.id !== action.payload),
      };
    default:
      return state;
  }
};

// Create the PlayerContext
const PlayerContext = createContext(null);

// PlayerProvider component
export const PlayerProvider = ({ children }) => {
  const [state, dispatch] = useReducer(playerReducer, initialState);

  // Fetch players from the API
  const fetchPlayers = async () => {
    try {
      const response = await apiClient.get('/player');
      const players = response.data.sort((a, b) => a.name.localeCompare(b.name));
      // Remove 'notes' from player objects if present
      const playersWithoutNotes = players.map((player) => {
        const { notes, ...rest } = player;
        return rest;
      });
      dispatch({ type: SET_PLAYERS, payload: playersWithoutNotes });
    } catch (error) {
      console.error('Error fetching players:', error);
    }
  };

  // Fetch tags from the API
  const fetchTags = async () => {
    try {
      const response = await apiClient.get('/tag');
      dispatch({ type: SET_TAGS, payload: response.data });
    } catch (error) {
      console.error('Error fetching tags:', error);
    }
  };

  // Fetch notes from the API
  const fetchNotes = async () => {
    try {
      const response = await apiClient.get('/note');
      dispatch({ type: SET_NOTES, payload: response.data });
    } catch (error) {
      console.error('Error fetching notes:', error);
    }
  };

  useEffect(() => {
    fetchPlayers();
    fetchTags();
    fetchNotes();
  }, []);

  // Function to save a player (either add or update)
  const savePlayer = async (player) => {
    try {
      let response;
      if (player.id) {
        response = await apiClient.put(`/player/${player.id}`, player);
        dispatch({ type: UPDATE_PLAYER, payload: response.data });
      } else {
        response = await apiClient.post('/player', player);
        dispatch({ type: ADD_PLAYER, payload: response.data });
      }
      return response.data; // Return the saved player data
    } catch (error) {
      console.error('Error saving player:', error);
      throw error; // Rethrow the error to handle it in the component if needed
    }
  };

  // Function to delete a player
  const deletePlayer = async (playerId) => {
    try {
      await apiClient.delete(`/player/${playerId}`);
      dispatch({ type: DELETE_PLAYER, payload: playerId });
    } catch (error) {
      console.error('Error deleting player:', error);
      throw error;
    }
  };

  // Functions for notes management

  // Function to add a note
  const addNote = async (note) => {
    try {
      const response = await apiClient.post('/note', note);
      dispatch({ type: ADD_NOTE, payload: response.data });
      return response.data;
    } catch (error) {
      console.error('Error adding note:', error);
      throw error;
    }
  };

  // Function to update a note
  const updateNote = async (note) => {
    try {
      const response = await apiClient.put(`/note/${note.id}`, note);
      console.log('note.data', response.data);
      dispatch({ type: UPDATE_NOTE, payload: response.data });
      return response.data;
    } catch (error) {
      console.error('Error updating note:', error);
      throw error;
    }
  };

  // Function to delete a note
  const deleteNote = async (noteId) => {
    try {
      await apiClient.delete(`/note/${noteId}`);
      dispatch({ type: DELETE_NOTE, payload: noteId });
    } catch (error) {
      console.error('Error deleting note:', error);
      throw error;
    }
  };

  return (
    <PlayerContext.Provider
      value={{
        state,
        fetchPlayers,
        savePlayer,
        deletePlayer,
        addNote,
        updateNote,
        deleteNote,
      }}
    >
      {children}
    </PlayerContext.Provider>
  );
};

// Custom hook to use the PlayerContext
export const usePlayerContext = () => {
  const context = useContext(PlayerContext);
  if (!context) {
    throw new Error('usePlayerContext must be used within a PlayerProvider');
  }
  return context;
};
